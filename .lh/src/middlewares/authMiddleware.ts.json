{
    "sourceFile": "src/middlewares/authMiddleware.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1752751589794,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752752243697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+// gym-api/src/middlewares/authMiddleware.ts\r\n+import { Request, Response, NextFunction } from 'express';\r\n+import jwt from 'jsonwebtoken';\r\n+import { Role } from '@prisma/client'; // Assuming Role enum is accessible from Prisma client\r\n+\r\n+// Define the JWT payload interface to match what you put in the token\r\n+interface JwtPayload {\r\n+  id: string; // User.id\r\n+  email: string;\r\n+  role: Role;\r\n+  clubId?: string;\r\n+  profileType?: 'trainer' | 'member';\r\n+  profileId?: string; // Trainer.id or Member.id\r\n+  canCreateClasses?: boolean; // Trainer.canCreateClasses\r\n+  exp: number; // Expiration time (standard JWT field)\r\n+  iat: number; // Issued at time (standard JWT field)\r\n+}\r\n+\r\n+export const authMiddleware = (req: Request, res: Response, next: NextFunction) => {\r\n+  // 1. Check for Authorization header\r\n+  const authHeader = req.headers.authorization;\r\n+  if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n+    return res.status(401).json({ error: 'No token provided, authorization denied.' });\r\n+  }\r\n+\r\n+  const token = authHeader.split(' ')[1]; // Extract the token (e.g., \"Bearer YOUR_TOKEN\")\r\n+\r\n+  try {\r\n+    // 2. Verify the token using your JWT_SECRET\r\n+    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;\r\n+\r\n+    // 3. Attach user information from the decoded token to the request object\r\n+    // This makes `req.user` available in subsequent controllers\r\n+    req.user = {\r\n+      id: decoded.id,\r\n+      email: decoded.email,\r\n+      role: decoded.role,\r\n+      clubId: decoded.clubId,\r\n+      profileType: decoded.profileType,\r\n+      profileId: decoded.profileId,\r\n+      canCreateClasses: decoded.canCreateClasses,\r\n+    };\r\n+\r\n+    // 4. Proceed to the next middleware or route handler\r\n+    next();\r\n+  } catch (err) {\r\n+    console.error('Token verification failed:', err);\r\n+    // If token is invalid or expired, send 403 Forbidden\r\n+    return res.status(403).json({ error: 'Token is not valid or expired.' });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752809311198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,97 +6,75 @@\n // Define the JWT payload interface to match what you put in the token\r\n interface JwtPayload {\r\n   id: string; // User.id\r\n   email: string;\r\n-  role: Role;\r\n+  role: Role; // THIS IS THE KEY!\r\n   clubId?: string;\r\n   profileType?: 'trainer' | 'member';\r\n   profileId?: string; // Trainer.id or Member.id\r\n   canCreateClasses?: boolean; // Trainer.canCreateClasses\r\n   exp: number; // Expiration time (standard JWT field)\r\n   iat: number; // Issued at time (standard JWT field)\r\n }\r\n \r\n-export const authMiddleware = (req: Request, res: Response, next: NextFunction) => {\r\n-  // 1. Check for Authorization header\r\n-  const authHeader = req.headers.authorization;\r\n-  if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n-    return res.status(401).json({ error: 'No token provided, authorization denied.' });\r\n+// Extend the Request object to include user\r\n+// IMPORTANT: This declaration needs to be in a global type definition file\r\n+// like `src/@types/express.d.ts` or directly above the middleware\r\n+// to properly augment the Express Request interface across your project.\r\n+declare global {\r\n+  namespace Express {\r\n+    interface Request {\r\n+      user?: JwtPayload; // Now directly use JwtPayload as the type for req.user\r\n+    }\r\n   }\r\n-\r\n-  const token = authHeader.split(' ')[1]; // Extract the token (e.g., \"Bearer YOUR_TOKEN\")\r\n-\r\n-  try {\r\n-    // 2. Verify the token using your JWT_SECRET\r\n-    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;\r\n-\r\n-    // 3. Attach user information from the decoded token to the request object\r\n-    // This makes `req.user` available in subsequent controllers\r\n-    req.user = {\r\n-      id: decoded.id,\r\n-      email: decoded.email,\r\n-      role: decoded.role,\r\n-      clubId: decoded.clubId,\r\n-      profileType: decoded.profileType,\r\n-      profileId: decoded.profileId,\r\n-      canCreateClasses: decoded.canCreateClasses,\r\n-    };\r\n-\r\n-    // 4. Proceed to the next middleware or route handler\r\n-    next();\r\n-  } catch (err) {\r\n-    console.error('Token verification failed:', err);\r\n-    // If token is invalid or expired, send 403 Forbidden\r\n-    return res.status(403).json({ error: 'Token is not valid or expired.' });\r\n-  }\r\n-};\n-// gym-api/src/middlewares/authMiddleware.ts\r\n-import { Request, Response, NextFunction } from 'express';\r\n-import jwt from 'jsonwebtoken';\r\n-import { Role } from '@prisma/client'; // Assuming Role enum is accessible from Prisma client\r\n-\r\n-// Define the JWT payload interface to match what you put in the token\r\n-interface JwtPayload {\r\n-  id: string; // User.id\r\n-  email: string;\r\n-  role: Role;\r\n-  clubId?: string;\r\n-  profileType?: 'trainer' | 'member';\r\n-  profileId?: string; // Trainer.id or Member.id\r\n-  canCreateClasses?: boolean; // Trainer.canCreateClasses\r\n-  exp: number; // Expiration time (standard JWT field)\r\n-  iat: number; // Issued at time (standard JWT field)\r\n }\r\n \r\n export const authMiddleware = (req: Request, res: Response, next: NextFunction) => {\r\n+  // --- ADD THIS LOG ---\r\n+  console.log('Auth Middleware: Processing request...');\r\n+  // --- END LOG ---\r\n+\r\n   // 1. Check for Authorization header\r\n   const authHeader = req.headers.authorization;\r\n   if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n+    console.log('Auth Middleware: No Bearer token provided or malformed header.'); // ADD LOG\r\n     return res.status(401).json({ error: 'No token provided, authorization denied.' });\r\n   }\r\n \r\n   const token = authHeader.split(' ')[1]; // Extract the token (e.g., \"Bearer YOUR_TOKEN\")\r\n+  // --- ADD THIS LOG (be cautious with logging tokens in production) ---\r\n+  console.log('Auth Middleware: Extracted token (first 10 chars):', token.substring(0, 10) + '...');\r\n+  // --- END LOG ---\r\n \r\n   try {\r\n     // 2. Verify the token using your JWT_SECRET\r\n     const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;\r\n \r\n+    // --- ADD THIS LOG ---\r\n+    console.log('Auth Middleware: Decoded JWT payload:', decoded); // This shows what `jwt.verify` returns\r\n+    // --- END LOG ---\r\n+\r\n     // 3. Attach user information from the decoded token to the request object\r\n-    // This makes `req.user` available in subsequent controllers\r\n     req.user = {\r\n       id: decoded.id,\r\n       email: decoded.email,\r\n       role: decoded.role,\r\n       clubId: decoded.clubId,\r\n       profileType: decoded.profileType,\r\n       profileId: decoded.profileId,\r\n       canCreateClasses: decoded.canCreateClasses,\r\n+      exp: decoded.exp,\r\n+      iat: decoded.iat,\r\n     };\r\n \r\n+    // --- ADD THIS LOG ---\r\n+    console.log('Auth Middleware: req.user attached to request:', req.user); // This shows what's put on req.user\r\n+    // --- END LOG ---\r\n+\r\n     // 4. Proceed to the next middleware or route handler\r\n     next();\r\n   } catch (err) {\r\n-    console.error('Token verification failed:', err);\r\n+    console.error('Auth Middleware: Token verification failed. Error details:', err); // Log full error\r\n     // If token is invalid or expired, send 403 Forbidden\r\n     return res.status(403).json({ error: 'Token is not valid or expired.' });\r\n   }\r\n };\n\\ No newline at end of file\n"
                }
            ],
            "date": 1752751589794,
            "name": "Commit-0",
            "content": "// gym-api/src/middlewares/authMiddleware.ts\r\nimport { Request, Response, NextFunction } from 'express';\r\nimport jwt from 'jsonwebtoken';\r\nimport { Role } from '@prisma/client'; // Assuming Role enum is accessible from Prisma client\r\n\r\n// Define the JWT payload interface to match what you put in the token\r\ninterface JwtPayload {\r\n  id: string; // User.id\r\n  email: string;\r\n  role: Role;\r\n  clubId?: string;\r\n  profileType?: 'trainer' | 'member';\r\n  profileId?: string; // Trainer.id or Member.id\r\n  canCreateClasses?: boolean; // Trainer.canCreateClasses\r\n  exp: number; // Expiration time (standard JWT field)\r\n  iat: number; // Issued at time (standard JWT field)\r\n}\r\n\r\nexport const authMiddleware = (req: Request, res: Response, next: NextFunction) => {\r\n  // 1. Check for Authorization header\r\n  const authHeader = req.headers.authorization;\r\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n    return res.status(401).json({ error: 'No token provided, authorization denied.' });\r\n  }\r\n\r\n  const token = authHeader.split(' ')[1]; // Extract the token (e.g., \"Bearer YOUR_TOKEN\")\r\n\r\n  try {\r\n    // 2. Verify the token using your JWT_SECRET\r\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;\r\n\r\n    // 3. Attach user information from the decoded token to the request object\r\n    // This makes `req.user` available in subsequent controllers\r\n    req.user = {\r\n      id: decoded.id,\r\n      email: decoded.email,\r\n      role: decoded.role,\r\n      clubId: decoded.clubId,\r\n      profileType: decoded.profileType,\r\n      profileId: decoded.profileId,\r\n      canCreateClasses: decoded.canCreateClasses,\r\n    };\r\n\r\n    // 4. Proceed to the next middleware or route handler\r\n    next();\r\n  } catch (err) {\r\n    console.error('Token verification failed:', err);\r\n    // If token is invalid or expired, send 403 Forbidden\r\n    return res.status(403).json({ error: 'Token is not valid or expired.' });\r\n  }\r\n};"
        }
    ]
}