{
    "sourceFile": "src/utils/authUtils.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1752733010949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752904279685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n import bcrypt from 'bcryptjs';\r\n import jwt from 'jsonwebtoken';\r\n import crypto from 'crypto';\r\n \r\n-const JWT_SECRET = process.env.JWT_SECRET || 'supersecretjwtkey'; // Use a strong secret!\r\n+const JWT_SECRET = process.env.JWT_SECRET || 'supersecretjwtkey';\r\n \r\n export const hashPassword = async (password: string): Promise<string> => {\r\n   const salt = await bcrypt.genSalt(10);\r\n   return bcrypt.hash(password, salt);\r\n@@ -15,31 +15,64 @@\n };\r\n \r\n // Generates a secure random token for password reset\r\n export const generatePasswordResetToken = (): { token: string; hashedToken: string; expires: Date } => {\r\n-  const token = crypto.randomBytes(32).toString('hex'); // Generate a random token\r\n-  const hashedToken = crypto.createHash('sha256').update(token).digest('hex'); // Hash it for DB storage\r\n-\r\n+  const token = crypto.randomBytes(32).toString('hex');\r\n+  const hashedToken = crypto.createHash('sha256').update(token).digest('hex');\r\n   const expires = new Date(Date.now() + 3600000); // Token valid for 1 hour\r\n-\r\n   return { token, hashedToken, expires };\r\n };\r\n \r\n // Generates a JWT for the password setup link\r\n export const generatePasswordSetupToken = (userId: string, email: string): string => {\r\n-  return jwt.sign({ userId, email, type: 'password_setup' }, JWT_SECRET, { expiresIn: '1h' }); // Token expires in 1 hour\r\n+  console.log('Generate Token Debug: Creating token for userId:', userId, 'email:', email);\r\n+  \r\n+  if (!userId) {\r\n+    throw new Error('User ID is required to generate password setup token');\r\n+  }\r\n+  \r\n+  const payload = { \r\n+    userId, \r\n+    email, \r\n+    type: 'password_setup' \r\n+  };\r\n+  \r\n+  console.log('Generate Token Debug: Token payload:', payload);\r\n+  \r\n+  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' });\r\n+  \r\n+  console.log('Generate Token Debug: Token created successfully');\r\n+  \r\n+  return token;\r\n };\r\n \r\n // Verifies the password setup JWT\r\n export const verifyPasswordSetupToken = (token: string): { userId: string; email: string; type: string } | null => {\r\n   try {\r\n+    console.log('Verify Token Debug: Attempting to verify token...');\r\n+    \r\n     const decoded = jwt.verify(token, JWT_SECRET) as { userId: string; email: string; type: string; iat: number; exp: number };\r\n+    \r\n+    console.log('Verify Token Debug: Token decoded successfully:', {\r\n+      userId: decoded.userId,\r\n+      email: decoded.email,\r\n+      type: decoded.type,\r\n+      exp: new Date(decoded.exp * 1000), // Convert to readable date\r\n+    });\r\n+    \r\n     if (decoded.type !== 'password_setup') {\r\n-      return null; // Ensure it's the correct type of token\r\n+      console.error('Verify Token Error: Invalid token type:', decoded.type);\r\n+      return null;\r\n     }\r\n+    \r\n+    if (!decoded.userId) {\r\n+      console.error('Verify Token Error: Token missing userId');\r\n+      return null;\r\n+    }\r\n+    \r\n     return decoded;\r\n   } catch (error) {\r\n-    console.error(\"Error verifying password setup token:\", error);\r\n+    console.error(\"Verify Token Error: Error verifying password setup token:\", error);\r\n     return null;\r\n   }\r\n };\r\n \r\n"
                },
                {
                    "date": 1752904629078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,55 +24,76 @@\n \r\n // Generates a JWT for the password setup link\r\n export const generatePasswordSetupToken = (userId: string, email: string): string => {\r\n   console.log('Generate Token Debug: Creating token for userId:', userId, 'email:', email);\r\n+  console.log('Generate Token Debug: userId type:', typeof userId, 'userId value:', userId);\r\n   \r\n-  if (!userId) {\r\n+  if (!userId || userId === 'null' || userId === 'undefined') {\r\n+    console.error('Generate Token Error: Invalid userId provided:', userId);\r\n     throw new Error('User ID is required to generate password setup token');\r\n   }\r\n   \r\n   const payload = { \r\n-    userId, \r\n+    userId: userId.toString(), // Ensure it's a string\r\n     email, \r\n     type: 'password_setup' \r\n   };\r\n   \r\n   console.log('Generate Token Debug: Token payload:', payload);\r\n+  console.log('Generate Token Debug: JWT_SECRET exists:', !!JWT_SECRET);\r\n   \r\n   const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' });\r\n   \r\n-  console.log('Generate Token Debug: Token created successfully');\r\n+  console.log('Generate Token Debug: Token created successfully, length:', token.length);\r\n+  console.log('Generate Token Debug: Token first 50 chars:', token.substring(0, 50));\r\n   \r\n   return token;\r\n };\r\n \r\n // Verifies the password setup JWT\r\n export const verifyPasswordSetupToken = (token: string): { userId: string; email: string; type: string } | null => {\r\n   try {\r\n     console.log('Verify Token Debug: Attempting to verify token...');\r\n+    console.log('Verify Token Debug: Token length:', token.length);\r\n+    console.log('Verify Token Debug: Token first 50 chars:', token.substring(0, 50));\r\n+    console.log('Verify Token Debug: JWT_SECRET exists:', !!JWT_SECRET);\r\n     \r\n-    const decoded = jwt.verify(token, JWT_SECRET) as { userId: string; email: string; type: string; iat: number; exp: number };\r\n+    const decoded = jwt.verify(token, JWT_SECRET) as any;\r\n     \r\n-    console.log('Verify Token Debug: Token decoded successfully:', {\r\n-      userId: decoded.userId,\r\n-      email: decoded.email,\r\n-      type: decoded.type,\r\n-      exp: new Date(decoded.exp * 1000), // Convert to readable date\r\n-    });\r\n+    console.log('Verify Token Debug: Raw decoded token:', decoded);\r\n+    console.log('Verify Token Debug: Decoded keys:', Object.keys(decoded));\r\n     \r\n+    // Check all possible variations of userId field\r\n+    const userId = decoded.userId || decoded.id || decoded.user_id;\r\n+    \r\n+    console.log('Verify Token Debug: Extracted userId:', userId);\r\n+    console.log('Verify Token Debug: userId type:', typeof userId);\r\n+    \r\n     if (decoded.type !== 'password_setup') {\r\n       console.error('Verify Token Error: Invalid token type:', decoded.type);\r\n       return null;\r\n     }\r\n     \r\n-    if (!decoded.userId) {\r\n+    if (!userId) {\r\n       console.error('Verify Token Error: Token missing userId');\r\n+      console.error('Verify Token Error: Full decoded object:', JSON.stringify(decoded, null, 2));\r\n       return null;\r\n     }\r\n     \r\n-    return decoded;\r\n+    const result = {\r\n+      userId: userId.toString(),\r\n+      email: decoded.email,\r\n+      type: decoded.type\r\n+    };\r\n+    \r\n+    console.log('Verify Token Debug: Returning result:', result);\r\n+    \r\n+    return result;\r\n   } catch (error) {\r\n     console.error(\"Verify Token Error: Error verifying password setup token:\", error);\r\n+    if (error instanceof jwt.JsonWebTokenError) {\r\n+      console.error(\"Verify Token Error: JWT Error details:\", error.message);\r\n+    }\r\n     return null;\r\n   }\r\n };\r\n \r\n"
                }
            ],
            "date": 1752733010949,
            "name": "Commit-0",
            "content": "// src/utils/authUtils.ts\r\nimport bcrypt from 'bcryptjs';\r\nimport jwt from 'jsonwebtoken';\r\nimport crypto from 'crypto';\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'supersecretjwtkey'; // Use a strong secret!\r\n\r\nexport const hashPassword = async (password: string): Promise<string> => {\r\n  const salt = await bcrypt.genSalt(10);\r\n  return bcrypt.hash(password, salt);\r\n};\r\n\r\nexport const comparePasswords = async (password: string, hash: string): Promise<boolean> => {\r\n  return bcrypt.compare(password, hash);\r\n};\r\n\r\n// Generates a secure random token for password reset\r\nexport const generatePasswordResetToken = (): { token: string; hashedToken: string; expires: Date } => {\r\n  const token = crypto.randomBytes(32).toString('hex'); // Generate a random token\r\n  const hashedToken = crypto.createHash('sha256').update(token).digest('hex'); // Hash it for DB storage\r\n\r\n  const expires = new Date(Date.now() + 3600000); // Token valid for 1 hour\r\n\r\n  return { token, hashedToken, expires };\r\n};\r\n\r\n// Generates a JWT for the password setup link\r\nexport const generatePasswordSetupToken = (userId: string, email: string): string => {\r\n  return jwt.sign({ userId, email, type: 'password_setup' }, JWT_SECRET, { expiresIn: '1h' }); // Token expires in 1 hour\r\n};\r\n\r\n// Verifies the password setup JWT\r\nexport const verifyPasswordSetupToken = (token: string): { userId: string; email: string; type: string } | null => {\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as { userId: string; email: string; type: string; iat: number; exp: number };\r\n    if (decoded.type !== 'password_setup') {\r\n      return null; // Ensure it's the correct type of token\r\n    }\r\n    return decoded;\r\n  } catch (error) {\r\n    console.error(\"Error verifying password setup token:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// You might also need a `generateRandomPassword` function if you go the temporary password route\r\nexport const generateRandomPassword = (length = 12): string => {\r\n  const charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+\";\r\n  let password = \"\";\r\n  for (let i = 0; i < length; i++) {\r\n    const randomIndex = Math.floor(Math.random() * charset.length);\r\n    password += charset[randomIndex];\r\n  }\r\n  return password;\r\n};"
        }
    ]
}