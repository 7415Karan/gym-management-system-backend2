{
    "sourceFile": "src/controllers/schedule.controller.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1752751780645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752752254462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,234 @@\n+// gym-api/src/controllers/schedule.controller.ts\r\n+import { Request, Response } from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+\r\n+const prisma = new PrismaClient();\r\n+\r\n+// Extend Request to include user property from auth middleware\r\n+interface AuthenticatedRequest extends Request {\r\n+  user?: {\r\n+    id: string; // User.id\r\n+    profileId?: string; // Trainer.id (if role is trainer)\r\n+    role: string; // User.role\r\n+    clubId?: string;\r\n+    canCreateClasses?: boolean;\r\n+  };\r\n+}\r\n+\r\n+// GET /api/schedule/trainer/my - Fetch classes for the logged-in trainer\r\n+export const getTrainerSchedule = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const trainerId = req.user?.profileId; // Use profileId (Trainer.id)\r\n+  const userRole = req.user?.role;\r\n+\r\n+  if (userRole !== 'trainer' || !trainerId) {\r\n+    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n+  }\r\n+\r\n+  const { startDate, endDate, classType, status } = req.query;\r\n+\r\n+  try {\r\n+    const classes = await prisma.classSchedule.findMany({\r\n+      where: {\r\n+        trainerId: trainerId, // Filter by the authenticated trainer's ID\r\n+        date: {\r\n+          gte: startDate ? new Date(String(startDate)) : undefined,\r\n+          lte: endDate ? new Date(String(endDate)) : undefined,\r\n+        },\r\n+        classType: classType ? String(classType) : undefined,\r\n+        status: status ? String(status) : undefined,\r\n+      },\r\n+      include: {\r\n+        trainer: { select: { name: true } }, // Include trainer name for display\r\n+        bookings: {\r\n+          where: { status: 'confirmed' }, // Count confirmed bookings\r\n+          select: { id: true }\r\n+        },\r\n+        attendances: { // Include for class attendance summary\r\n+          select: { id: true, status: true }\r\n+        },\r\n+        location: { select: { name: true } } // Include location name\r\n+      },\r\n+      orderBy: [{ date: 'asc' }],\r\n+    });\r\n+\r\n+    const classesWithDetails = classes.map(cls => ({\r\n+      ...cls,\r\n+      // Format date for consistent display if needed, otherwise send as is\r\n+      date: cls.date.toISOString(), // Ensure it's an ISO string for frontend parsing\r\n+      trainerName: cls.trainer.name, // Use the name from the included trainer\r\n+      location: cls.location?.name || 'N/A', // Use location name\r\n+      currentAttendance: cls.bookings.length,\r\n+      totalAttended: cls.attendances.filter(att => att.status === 'present').length,\r\n+      totalAbsent: cls.attendances.filter(att => att.status === 'absent').length,\r\n+    }));\r\n+\r\n+    res.json(classesWithDetails);\r\n+  } catch (error) {\r\n+    console.error('Error fetching trainer classes:', error);\r\n+    res.status(500).json({ error: 'Error fetching trainer classes' });\r\n+  }\r\n+};\r\n+\r\n+// POST /api/schedule/trainer - Create a new class by trainer\r\n+export const createClass = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const trainerId = req.user?.profileId; // Trainer's actual ID\r\n+  const clubId = req.user?.clubId; // Trainer's club ID\r\n+  const canCreateClasses = req.user?.canCreateClasses; // Permission from JWT\r\n+\r\n+  if (req.user?.role !== 'trainer' || !trainerId || !clubId) {\r\n+    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n+  }\r\n+  if (!canCreateClasses) {\r\n+    return res.status(403).json({ error: 'Not authorized to create classes.' });\r\n+  }\r\n+\r\n+  const { title, date, time, locationId, maxCapacity, duration, classType } = req.body;\r\n+\r\n+  if (!title || !date || !time || !locationId || !maxCapacity || !duration || !classType) {\r\n+    return res.status(400).json({ error: 'Missing required fields to create class.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const classDateTime = new Date(`${date}T${time}:00`); // Combine date and time\r\n+\r\n+    const newClass = await prisma.classSchedule.create({\r\n+      data: {\r\n+        title,\r\n+        date: classDateTime,\r\n+        locationId,\r\n+        clubId,\r\n+        trainerId, // Auto-assign to logged-in trainer\r\n+        maxCapacity,\r\n+        duration,\r\n+        classType,\r\n+        status: 'scheduled',\r\n+      },\r\n+      include: {\r\n+        trainer: { select: { name: true } },\r\n+        location: { select: { name: true } }\r\n+      }\r\n+    });\r\n+\r\n+    // Format for consistent frontend response\r\n+    const formattedClass = {\r\n+        ...newClass,\r\n+        date: newClass.date.toISOString(),\r\n+        trainerName: newClass.trainer.name,\r\n+        location: newClass.location?.name || 'N/A',\r\n+        currentAttendance: 0, // New class has 0 attendance\r\n+        totalAttended: 0,\r\n+        totalAbsent: 0,\r\n+    };\r\n+\r\n+    res.status(201).json(formattedClass);\r\n+  } catch (error) {\r\n+    console.error('Error creating class:', error);\r\n+    res.status(500).json({ error: 'Failed to create class.' });\r\n+  }\r\n+};\r\n+\r\n+// PATCH /api/schedule/trainer/:id - Update a class by trainer\r\n+export const updateClass = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const trainerId = req.user?.profileId;\r\n+  const { id } = req.params; // Class Schedule ID\r\n+  const { title, date, time, locationId, maxCapacity, duration, classType, status } = req.body;\r\n+\r\n+  if (req.user?.role !== 'trainer' || !trainerId) {\r\n+    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const existingClass = await prisma.classSchedule.findUnique({\r\n+      where: { id },\r\n+      select: { trainerId: true, date: true } // Select date to preserve time if only date is updated\r\n+    });\r\n+\r\n+    if (!existingClass || existingClass.trainerId !== trainerId) {\r\n+      return res.status(403).json({ error: 'Not authorized to update this class.' });\r\n+    }\r\n+\r\n+    const updatedData: any = {\r\n+      title,\r\n+      locationId,\r\n+      maxCapacity,\r\n+      duration,\r\n+      classType,\r\n+      status // Allow updating status (e.g., to 'cancelled' or 'completed')\r\n+    };\r\n+\r\n+    // Handle date and time updates\r\n+    if (date && time) {\r\n+      updatedData.date = new Date(`${date}T${time}:00`);\r\n+    } else if (date) {\r\n+      // If only date is provided, preserve existing time\r\n+      const existingDateTime = existingClass.date;\r\n+      const newDate = new Date(date);\r\n+      newDate.setHours(existingDateTime.getHours(), existingDateTime.getMinutes(), existingDateTime.getSeconds(), existingDateTime.getMilliseconds());\r\n+      updatedData.date = newDate;\r\n+    } else if (time) {\r\n+        // If only time is provided, update existing date's time\r\n+        const existingDateTime = existingClass.date;\r\n+        const [hours, minutes] = time.split(':').map(Number);\r\n+        existingDateTime.setHours(hours, minutes, 0, 0);\r\n+        updatedData.date = existingDateTime;\r\n+    }\r\n+\r\n+\r\n+    const updatedClass = await prisma.classSchedule.update({\r\n+      where: { id },\r\n+      data: updatedData,\r\n+      include: {\r\n+        trainer: { select: { name: true } },\r\n+        bookings: { where: { status: 'confirmed' }, select: { id: true } },\r\n+        attendances: { select: { id: true, status: true } },\r\n+        location: { select: { name: true } }\r\n+      }\r\n+    });\r\n+\r\n+    const formattedClass = {\r\n+        ...updatedClass,\r\n+        date: updatedClass.date.toISOString(),\r\n+        trainerName: updatedClass.trainer.name,\r\n+        location: updatedClass.location?.name || 'N/A',\r\n+        currentAttendance: updatedClass.bookings.length,\r\n+        totalAttended: updatedClass.attendances.filter(att => att.status === 'present').length,\r\n+        totalAbsent: updatedClass.attendances.filter(att => att.status === 'absent').length,\r\n+    };\r\n+\r\n+    res.json(formattedClass);\r\n+  } catch (error) {\r\n+    console.error('Error updating class:', error);\r\n+    res.status(500).json({ error: 'Failed to update class.' });\r\n+  }\r\n+};\r\n+\r\n+// DELETE /api/schedule/trainer/:id - Cancel a class by trainer (updates status to 'cancelled')\r\n+export const cancelClass = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const trainerId = req.user?.profileId;\r\n+  const { id } = req.params; // Class Schedule ID\r\n+\r\n+  if (req.user?.role !== 'trainer' || !trainerId) {\r\n+    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const existingClass = await prisma.classSchedule.findUnique({\r\n+      where: { id },\r\n+      select: { trainerId: true }\r\n+    });\r\n+\r\n+    if (!existingClass || existingClass.trainerId !== trainerId) {\r\n+      return res.status(403).json({ error: 'Not authorized to cancel this class.' });\r\n+    }\r\n+\r\n+    // Update status to 'cancelled' (recommended over hard delete for history)\r\n+    const cancelledClass = await prisma.classSchedule.update({\r\n+      where: { id },\r\n+      data: { status: 'cancelled' },\r\n+    });\r\n+    res.json(cancelledClass); // Return the updated class\r\n+  } catch (error) {\r\n+    console.error('Error cancelling class:', error);\r\n+    res.status(500).json({ error: 'Failed to cancel class.' });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752752324595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -230,239 +230,5 @@\n   } catch (error) {\r\n     console.error('Error cancelling class:', error);\r\n     res.status(500).json({ error: 'Failed to cancel class.' });\r\n   }\r\n-};\n-// gym-api/src/controllers/schedule.controller.ts\r\n-import { Request, Response } from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-\r\n-const prisma = new PrismaClient();\r\n-\r\n-// Extend Request to include user property from auth middleware\r\n-interface AuthenticatedRequest extends Request {\r\n-  user?: {\r\n-    id: string; // User.id\r\n-    profileId?: string; // Trainer.id (if role is trainer)\r\n-    role: string; // User.role\r\n-    clubId?: string;\r\n-    canCreateClasses?: boolean;\r\n-  };\r\n-}\r\n-\r\n-// GET /api/schedule/trainer/my - Fetch classes for the logged-in trainer\r\n-export const getTrainerSchedule = async (req: AuthenticatedRequest, res: Response) => {\r\n-  const trainerId = req.user?.profileId; // Use profileId (Trainer.id)\r\n-  const userRole = req.user?.role;\r\n-\r\n-  if (userRole !== 'trainer' || !trainerId) {\r\n-    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n-  }\r\n-\r\n-  const { startDate, endDate, classType, status } = req.query;\r\n-\r\n-  try {\r\n-    const classes = await prisma.classSchedule.findMany({\r\n-      where: {\r\n-        trainerId: trainerId, // Filter by the authenticated trainer's ID\r\n-        date: {\r\n-          gte: startDate ? new Date(String(startDate)) : undefined,\r\n-          lte: endDate ? new Date(String(endDate)) : undefined,\r\n-        },\r\n-        classType: classType ? String(classType) : undefined,\r\n-        status: status ? String(status) : undefined,\r\n-      },\r\n-      include: {\r\n-        trainer: { select: { name: true } }, // Include trainer name for display\r\n-        bookings: {\r\n-          where: { status: 'confirmed' }, // Count confirmed bookings\r\n-          select: { id: true }\r\n-        },\r\n-        attendances: { // Include for class attendance summary\r\n-          select: { id: true, status: true }\r\n-        },\r\n-        location: { select: { name: true } } // Include location name\r\n-      },\r\n-      orderBy: [{ date: 'asc' }],\r\n-    });\r\n-\r\n-    const classesWithDetails = classes.map(cls => ({\r\n-      ...cls,\r\n-      // Format date for consistent display if needed, otherwise send as is\r\n-      date: cls.date.toISOString(), // Ensure it's an ISO string for frontend parsing\r\n-      trainerName: cls.trainer.name, // Use the name from the included trainer\r\n-      location: cls.location?.name || 'N/A', // Use location name\r\n-      currentAttendance: cls.bookings.length,\r\n-      totalAttended: cls.attendances.filter(att => att.status === 'present').length,\r\n-      totalAbsent: cls.attendances.filter(att => att.status === 'absent').length,\r\n-    }));\r\n-\r\n-    res.json(classesWithDetails);\r\n-  } catch (error) {\r\n-    console.error('Error fetching trainer classes:', error);\r\n-    res.status(500).json({ error: 'Error fetching trainer classes' });\r\n-  }\r\n-};\r\n-\r\n-// POST /api/schedule/trainer - Create a new class by trainer\r\n-export const createClass = async (req: AuthenticatedRequest, res: Response) => {\r\n-  const trainerId = req.user?.profileId; // Trainer's actual ID\r\n-  const clubId = req.user?.clubId; // Trainer's club ID\r\n-  const canCreateClasses = req.user?.canCreateClasses; // Permission from JWT\r\n-\r\n-  if (req.user?.role !== 'trainer' || !trainerId || !clubId) {\r\n-    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n-  }\r\n-  if (!canCreateClasses) {\r\n-    return res.status(403).json({ error: 'Not authorized to create classes.' });\r\n-  }\r\n-\r\n-  const { title, date, time, locationId, maxCapacity, duration, classType } = req.body;\r\n-\r\n-  if (!title || !date || !time || !locationId || !maxCapacity || !duration || !classType) {\r\n-    return res.status(400).json({ error: 'Missing required fields to create class.' });\r\n-  }\r\n-\r\n-  try {\r\n-    const classDateTime = new Date(`${date}T${time}:00`); // Combine date and time\r\n-\r\n-    const newClass = await prisma.classSchedule.create({\r\n-      data: {\r\n-        title,\r\n-        date: classDateTime,\r\n-        locationId,\r\n-        clubId,\r\n-        trainerId, // Auto-assign to logged-in trainer\r\n-        maxCapacity,\r\n-        duration,\r\n-        classType,\r\n-        status: 'scheduled',\r\n-      },\r\n-      include: {\r\n-        trainer: { select: { name: true } },\r\n-        location: { select: { name: true } }\r\n-      }\r\n-    });\r\n-\r\n-    // Format for consistent frontend response\r\n-    const formattedClass = {\r\n-        ...newClass,\r\n-        date: newClass.date.toISOString(),\r\n-        trainerName: newClass.trainer.name,\r\n-        location: newClass.location?.name || 'N/A',\r\n-        currentAttendance: 0, // New class has 0 attendance\r\n-        totalAttended: 0,\r\n-        totalAbsent: 0,\r\n-    };\r\n-\r\n-    res.status(201).json(formattedClass);\r\n-  } catch (error) {\r\n-    console.error('Error creating class:', error);\r\n-    res.status(500).json({ error: 'Failed to create class.' });\r\n-  }\r\n-};\r\n-\r\n-// PATCH /api/schedule/trainer/:id - Update a class by trainer\r\n-export const updateClass = async (req: AuthenticatedRequest, res: Response) => {\r\n-  const trainerId = req.user?.profileId;\r\n-  const { id } = req.params; // Class Schedule ID\r\n-  const { title, date, time, locationId, maxCapacity, duration, classType, status } = req.body;\r\n-\r\n-  if (req.user?.role !== 'trainer' || !trainerId) {\r\n-    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n-  }\r\n-\r\n-  try {\r\n-    const existingClass = await prisma.classSchedule.findUnique({\r\n-      where: { id },\r\n-      select: { trainerId: true, date: true } // Select date to preserve time if only date is updated\r\n-    });\r\n-\r\n-    if (!existingClass || existingClass.trainerId !== trainerId) {\r\n-      return res.status(403).json({ error: 'Not authorized to update this class.' });\r\n-    }\r\n-\r\n-    const updatedData: any = {\r\n-      title,\r\n-      locationId,\r\n-      maxCapacity,\r\n-      duration,\r\n-      classType,\r\n-      status // Allow updating status (e.g., to 'cancelled' or 'completed')\r\n-    };\r\n-\r\n-    // Handle date and time updates\r\n-    if (date && time) {\r\n-      updatedData.date = new Date(`${date}T${time}:00`);\r\n-    } else if (date) {\r\n-      // If only date is provided, preserve existing time\r\n-      const existingDateTime = existingClass.date;\r\n-      const newDate = new Date(date);\r\n-      newDate.setHours(existingDateTime.getHours(), existingDateTime.getMinutes(), existingDateTime.getSeconds(), existingDateTime.getMilliseconds());\r\n-      updatedData.date = newDate;\r\n-    } else if (time) {\r\n-        // If only time is provided, update existing date's time\r\n-        const existingDateTime = existingClass.date;\r\n-        const [hours, minutes] = time.split(':').map(Number);\r\n-        existingDateTime.setHours(hours, minutes, 0, 0);\r\n-        updatedData.date = existingDateTime;\r\n-    }\r\n-\r\n-\r\n-    const updatedClass = await prisma.classSchedule.update({\r\n-      where: { id },\r\n-      data: updatedData,\r\n-      include: {\r\n-        trainer: { select: { name: true } },\r\n-        bookings: { where: { status: 'confirmed' }, select: { id: true } },\r\n-        attendances: { select: { id: true, status: true } },\r\n-        location: { select: { name: true } }\r\n-      }\r\n-    });\r\n-\r\n-    const formattedClass = {\r\n-        ...updatedClass,\r\n-        date: updatedClass.date.toISOString(),\r\n-        trainerName: updatedClass.trainer.name,\r\n-        location: updatedClass.location?.name || 'N/A',\r\n-        currentAttendance: updatedClass.bookings.length,\r\n-        totalAttended: updatedClass.attendances.filter(att => att.status === 'present').length,\r\n-        totalAbsent: updatedClass.attendances.filter(att => att.status === 'absent').length,\r\n-    };\r\n-\r\n-    res.json(formattedClass);\r\n-  } catch (error) {\r\n-    console.error('Error updating class:', error);\r\n-    res.status(500).json({ error: 'Failed to update class.' });\r\n-  }\r\n-};\r\n-\r\n-// DELETE /api/schedule/trainer/:id - Cancel a class by trainer (updates status to 'cancelled')\r\n-export const cancelClass = async (req: AuthenticatedRequest, res: Response) => {\r\n-  const trainerId = req.user?.profileId;\r\n-  const { id } = req.params; // Class Schedule ID\r\n-\r\n-  if (req.user?.role !== 'trainer' || !trainerId) {\r\n-    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n-  }\r\n-\r\n-  try {\r\n-    const existingClass = await prisma.classSchedule.findUnique({\r\n-      where: { id },\r\n-      select: { trainerId: true }\r\n-    });\r\n-\r\n-    if (!existingClass || existingClass.trainerId !== trainerId) {\r\n-      return res.status(403).json({ error: 'Not authorized to cancel this class.' });\r\n-    }\r\n-\r\n-    // Update status to 'cancelled' (recommended over hard delete for history)\r\n-    const cancelledClass = await prisma.classSchedule.update({\r\n-      where: { id },\r\n-      data: { status: 'cancelled' },\r\n-    });\r\n-    res.json(cancelledClass); // Return the updated class\r\n-  } catch (error) {\r\n-    console.error('Error cancelling class:', error);\r\n-    res.status(500).json({ error: 'Failed to cancel class.' });\r\n-  }\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752757586678,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,15 +7,20 @@\n // Extend Request to include user property from auth middleware\r\n interface AuthenticatedRequest extends Request {\r\n   user?: {\r\n     id: string; // User.id\r\n-    profileId?: string; // Trainer.id (if role is trainer)\r\n+    profileId?: string; // Trainer.id or Member.id (if applicable)\r\n     role: string; // User.role\r\n-    clubId?: string;\r\n-    canCreateClasses?: boolean;\r\n+    clubId?: string; // Club.id (for franchise_admin, trainer, member)\r\n+    canCreateClasses?: boolean; // Trainer.canCreateClasses\r\n   };\r\n }\r\n \r\n+// ====================================================================================\r\n+// --- TRAINER-SPECIFIC CLASS MANAGEMENT FUNCTIONS ---\r\n+// = These functions operate on classes assigned to the logged-in trainer's profileId.\r\n+// ====================================================================================\r\n+\r\n // GET /api/schedule/trainer/my - Fetch classes for the logged-in trainer\r\n export const getTrainerSchedule = async (req: AuthenticatedRequest, res: Response) => {\r\n   const trainerId = req.user?.profileId; // Use profileId (Trainer.id)\r\n   const userRole = req.user?.role;\r\n@@ -52,9 +57,8 @@\n     });\r\n \r\n     const classesWithDetails = classes.map(cls => ({\r\n       ...cls,\r\n-      // Format date for consistent display if needed, otherwise send as is\r\n       date: cls.date.toISOString(), // Ensure it's an ISO string for frontend parsing\r\n       trainerName: cls.trainer.name, // Use the name from the included trainer\r\n       location: cls.location?.name || 'N/A', // Use location name\r\n       currentAttendance: cls.bookings.length,\r\n@@ -88,9 +92,9 @@\n     return res.status(400).json({ error: 'Missing required fields to create class.' });\r\n   }\r\n \r\n   try {\r\n-    const classDateTime = new Date(`${date}T${time}:00`); // Combine date and time\r\n+    const classDateTime = new Date(`${date}T${time}:00`);\r\n \r\n     const newClass = await prisma.classSchedule.create({\r\n       data: {\r\n         title,\r\n@@ -108,30 +112,29 @@\n         location: { select: { name: true } }\r\n       }\r\n     });\r\n \r\n-    // Format for consistent frontend response\r\n     const formattedClass = {\r\n         ...newClass,\r\n         date: newClass.date.toISOString(),\r\n         trainerName: newClass.trainer.name,\r\n         location: newClass.location?.name || 'N/A',\r\n-        currentAttendance: 0, // New class has 0 attendance\r\n+        currentAttendance: 0,\r\n         totalAttended: 0,\r\n         totalAbsent: 0,\r\n     };\r\n \r\n     res.status(201).json(formattedClass);\r\n   } catch (error) {\r\n-    console.error('Error creating class:', error);\r\n+    console.error('Error creating class by trainer:', error);\r\n     res.status(500).json({ error: 'Failed to create class.' });\r\n   }\r\n };\r\n \r\n // PATCH /api/schedule/trainer/:id - Update a class by trainer\r\n export const updateClass = async (req: AuthenticatedRequest, res: Response) => {\r\n   const trainerId = req.user?.profileId;\r\n-  const { id } = req.params; // Class Schedule ID\r\n+  const { id } = req.params;\r\n   const { title, date, time, locationId, maxCapacity, duration, classType, status } = req.body;\r\n \r\n   if (req.user?.role !== 'trainer' || !trainerId) {\r\n     return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n@@ -139,9 +142,9 @@\n \r\n   try {\r\n     const existingClass = await prisma.classSchedule.findUnique({\r\n       where: { id },\r\n-      select: { trainerId: true, date: true } // Select date to preserve time if only date is updated\r\n+      select: { trainerId: true, date: true }\r\n     });\r\n \r\n     if (!existingClass || existingClass.trainerId !== trainerId) {\r\n       return res.status(403).json({ error: 'Not authorized to update this class.' });\r\n@@ -152,29 +155,25 @@\n       locationId,\r\n       maxCapacity,\r\n       duration,\r\n       classType,\r\n-      status // Allow updating status (e.g., to 'cancelled' or 'completed')\r\n+      status\r\n     };\r\n \r\n-    // Handle date and time updates\r\n     if (date && time) {\r\n       updatedData.date = new Date(`${date}T${time}:00`);\r\n     } else if (date) {\r\n-      // If only date is provided, preserve existing time\r\n       const existingDateTime = existingClass.date;\r\n       const newDate = new Date(date);\r\n       newDate.setHours(existingDateTime.getHours(), existingDateTime.getMinutes(), existingDateTime.getSeconds(), existingDateTime.getMilliseconds());\r\n       updatedData.date = newDate;\r\n     } else if (time) {\r\n-        // If only time is provided, update existing date's time\r\n         const existingDateTime = existingClass.date;\r\n         const [hours, minutes] = time.split(':').map(Number);\r\n         existingDateTime.setHours(hours, minutes, 0, 0);\r\n         updatedData.date = existingDateTime;\r\n     }\r\n \r\n-\r\n     const updatedClass = await prisma.classSchedule.update({\r\n       where: { id },\r\n       data: updatedData,\r\n       include: {\r\n@@ -196,17 +195,17 @@\n     };\r\n \r\n     res.json(formattedClass);\r\n   } catch (error) {\r\n-    console.error('Error updating class:', error);\r\n+    console.error('Error updating class by trainer:', error);\r\n     res.status(500).json({ error: 'Failed to update class.' });\r\n   }\r\n };\r\n \r\n // DELETE /api/schedule/trainer/:id - Cancel a class by trainer (updates status to 'cancelled')\r\n export const cancelClass = async (req: AuthenticatedRequest, res: Response) => {\r\n   const trainerId = req.user?.profileId;\r\n-  const { id } = req.params; // Class Schedule ID\r\n+  const { id } = req.params;\r\n \r\n   if (req.user?.role !== 'trainer' || !trainerId) {\r\n     return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n   }\r\n@@ -220,15 +219,266 @@\n     if (!existingClass || existingClass.trainerId !== trainerId) {\r\n       return res.status(403).json({ error: 'Not authorized to cancel this class.' });\r\n     }\r\n \r\n-    // Update status to 'cancelled' (recommended over hard delete for history)\r\n     const cancelledClass = await prisma.classSchedule.update({\r\n       where: { id },\r\n       data: { status: 'cancelled' },\r\n     });\r\n-    res.json(cancelledClass); // Return the updated class\r\n+    res.json(cancelledClass);\r\n   } catch (error) {\r\n-    console.error('Error cancelling class:', error);\r\n+    console.error('Error cancelling class by trainer:', error);\r\n     res.status(500).json({ error: 'Failed to cancel class.' });\r\n   }\r\n+};\r\n+\r\n+\r\n+// ====================================================================================\r\n+// --- FRANCHISE ADMIN-SPECIFIC CLASS MANAGEMENT FUNCTIONS ---\r\n+// - These functions allow admins to manage classes across their entire club.\r\n+// - They can fetch all classes, create classes for any trainer, and update/delete any class.\r\n+// ====================================================================================\r\n+\r\n+// GET /api/schedule/admin/club - Fetch all classes for the logged-in franchise admin's club\r\n+export const getClassesByAdmin = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const adminClubId = req.user?.clubId;\r\n+  const userRole = req.user?.role;\r\n+\r\n+  if (userRole !== 'franchise_admin' || !adminClubId) {\r\n+    return res.status(403).json({ error: 'Access denied. Franchise Admin role required.' });\r\n+  }\r\n+\r\n+  const { startDate, endDate, classType, status, trainerId } = req.query; // Admin can filter by trainer\r\n+\r\n+  try {\r\n+    const classes = await prisma.classSchedule.findMany({\r\n+      where: {\r\n+        clubId: adminClubId, // Filter by the admin's club\r\n+        trainerId: trainerId ? String(trainerId) : undefined, // Optional filter by trainer\r\n+        date: {\r\n+          gte: startDate ? new Date(String(startDate)) : undefined,\r\n+          lte: endDate ? new Date(String(endDate)) : undefined,\r\n+        },\r\n+        classType: classType ? String(classType) : undefined,\r\n+        status: status ? String(status) : undefined,\r\n+      },\r\n+      include: {\r\n+        trainer: { select: { id: true, name: true } }, // Include trainer ID and name\r\n+        bookings: {\r\n+          where: { status: 'confirmed' },\r\n+          select: { id: true }\r\n+        },\r\n+        attendances: {\r\n+          select: { id: true, status: true }\r\n+        },\r\n+        location: { select: { name: true } }\r\n+      },\r\n+      orderBy: [{ date: 'asc' }],\r\n+    });\r\n+\r\n+    const classesWithDetails = classes.map(cls => ({\r\n+      ...cls,\r\n+      date: cls.date.toISOString(),\r\n+      trainerName: cls.trainer.name,\r\n+      location: cls.location?.name || 'N/A',\r\n+      currentAttendance: cls.bookings.length,\r\n+      totalAttended: cls.attendances.filter(att => att.status === 'present').length,\r\n+      totalAbsent: cls.attendances.filter(att => att.status === 'absent').length,\r\n+    }));\r\n+\r\n+    res.json(classesWithDetails);\r\n+  } catch (error) {\r\n+    console.error('Error fetching classes by admin:', error);\r\n+    res.status(500).json({ error: 'Error fetching classes by admin.' });\r\n+  }\r\n+};\r\n+\r\n+// POST /api/schedule/admin - Create a new class by admin\r\n+export const createClassByAdmin = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const adminClubId = req.user?.clubId;\r\n+  const userRole = req.user?.role;\r\n+\r\n+  if (userRole !== 'franchise_admin' || !adminClubId) {\r\n+    return res.status(403).json({ error: 'Access denied. Franchise Admin role required.' });\r\n+  }\r\n+\r\n+  const { title, date, time, locationId, trainerId, maxCapacity, duration, classType, status } = req.body;\r\n+\r\n+  if (!title || !date || !time || !locationId || !trainerId || !maxCapacity || !duration || !classType) {\r\n+    return res.status(400).json({ error: 'Missing required fields to create class.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const classDateTime = new Date(`${date}T${time}:00`);\r\n+\r\n+    // Verify if the assigned trainer belongs to the admin's club\r\n+    const trainer = await prisma.trainer.findUnique({\r\n+      where: { id: trainerId },\r\n+      select: { clubId: true }\r\n+    });\r\n+\r\n+    if (!trainer || trainer.clubId !== adminClubId) {\r\n+      return res.status(400).json({ error: 'Invalid trainer ID or trainer does not belong to your club.' });\r\n+    }\r\n+\r\n+    const newClass = await prisma.classSchedule.create({\r\n+      data: {\r\n+        title,\r\n+        date: classDateTime,\r\n+        locationId,\r\n+        clubId: adminClubId, // Assign to admin's club\r\n+        trainerId,          // Assign the specified trainer\r\n+        maxCapacity,\r\n+        duration,\r\n+        classType,\r\n+        status: status || 'scheduled', // Allow status to be set, default to 'scheduled'\r\n+      },\r\n+      include: {\r\n+        trainer: { select: { name: true } },\r\n+        location: { select: { name: true } }\r\n+      }\r\n+    });\r\n+\r\n+    const formattedClass = {\r\n+        ...newClass,\r\n+        date: newClass.date.toISOString(),\r\n+        trainerName: newClass.trainer.name,\r\n+        location: newClass.location?.name || 'N/A',\r\n+        currentAttendance: 0,\r\n+        totalAttended: 0,\r\n+        totalAbsent: 0,\r\n+    };\r\n+\r\n+    res.status(201).json(formattedClass);\r\n+  } catch (error) {\r\n+    console.error('Error creating class by admin:', error);\r\n+    res.status(500).json({ error: 'Failed to create class.' });\r\n+  }\r\n+};\r\n+\r\n+// PATCH /api/schedule/admin/:id - Update a class by admin\r\n+export const updateClassByAdmin = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const adminClubId = req.user?.clubId;\r\n+  const userRole = req.user?.role;\r\n+  const { id } = req.params;\r\n+  const { title, date, time, locationId, trainerId, maxCapacity, duration, classType, status } = req.body;\r\n+\r\n+  if (userRole !== 'franchise_admin' || !adminClubId) {\r\n+    return res.status(403).json({ error: 'Access denied. Franchise Admin role required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const existingClass = await prisma.classSchedule.findUnique({\r\n+      where: { id },\r\n+      select: { clubId: true, date: true } // Select clubId to ensure admin can only update classes in their club\r\n+    });\r\n+\r\n+    if (!existingClass || existingClass.clubId !== adminClubId) {\r\n+      return res.status(403).json({ error: 'Not authorized to update this class or class not found in your club.' });\r\n+    }\r\n+\r\n+    // If trainerId is provided, verify it belongs to the admin's club\r\n+    if (trainerId) {\r\n+        const trainer = await prisma.trainer.findUnique({\r\n+            where: { id: trainerId },\r\n+            select: { clubId: true }\r\n+        });\r\n+        if (!trainer || trainer.clubId !== adminClubId) {\r\n+            return res.status(400).json({ error: 'Invalid trainer ID or trainer does not belong to your club.' });\r\n+        }\r\n+    }\r\n+\r\n+    const updatedData: any = {\r\n+      title,\r\n+      locationId,\r\n+      trainerId, // Allow admin to change trainer\r\n+      maxCapacity,\r\n+      duration,\r\n+      classType,\r\n+      status\r\n+    };\r\n+\r\n+    if (date && time) {\r\n+      updatedData.date = new Date(`${date}T${time}:00`);\r\n+    } else if (date) {\r\n+      const existingDateTime = existingClass.date;\r\n+      const newDate = new Date(date);\r\n+      newDate.setHours(existingDateTime.getHours(), existingDateTime.getMinutes(), existingDateTime.getSeconds(), existingDateTime.getMilliseconds());\r\n+      updatedData.date = newDate;\r\n+    } else if (time) {\r\n+        const existingDateTime = existingClass.date;\r\n+        const [hours, minutes] = time.split(':').map(Number);\r\n+        existingDateTime.setHours(hours, minutes, 0, 0);\r\n+        updatedData.date = existingDateTime;\r\n+    }\r\n+\r\n+    const updatedClass = await prisma.classSchedule.update({\r\n+      where: { id },\r\n+      data: updatedData,\r\n+      include: {\r\n+        trainer: { select: { name: true } },\r\n+        bookings: { where: { status: 'confirmed' }, select: { id: true } },\r\n+        attendances: { select: { id: true, status: true } },\r\n+        location: { select: { name: true } }\r\n+      }\r\n+    });\r\n+\r\n+    const formattedClass = {\r\n+        ...updatedClass,\r\n+        date: updatedClass.date.toISOString(),\r\n+        trainerName: updatedClass.trainer.name,\r\n+        location: updatedClass.location?.name || 'N/A',\r\n+        currentAttendance: updatedClass.bookings.length,\r\n+        totalAttended: updatedClass.attendances.filter(att => att.status === 'present').length,\r\n+        totalAbsent: updatedClass.attendances.filter(att => att.status === 'absent').length,\r\n+    };\r\n+\r\n+    res.json(formattedClass);\r\n+  } catch (error) {\r\n+    console.error('Error updating class by admin:', error);\r\n+    res.status(500).json({ error: 'Failed to update class.' });\r\n+  }\r\n+};\r\n+\r\n+// DELETE /api/schedule/admin/:id - Delete/Cancel a class by admin\r\n+export const deleteClassByAdmin = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const adminClubId = req.user?.clubId;\r\n+  const userRole = req.user?.role;\r\n+  const { id } = req.params;\r\n+\r\n+  if (userRole !== 'franchise_admin' || !adminClubId) {\r\n+    return res.status(403).json({ error: 'Access denied. Franchise Admin role required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const existingClass = await prisma.classSchedule.findUnique({\r\n+      where: { id },\r\n+      select: { clubId: true }\r\n+    });\r\n+\r\n+    if (!existingClass || existingClass.clubId !== adminClubId) {\r\n+      return res.status(403).json({ error: 'Not authorized to delete this class or class not found in your club.' });\r\n+    }\r\n+\r\n+    // Option 1: Mark as cancelled (recommended for history/auditing)\r\n+    const cancelledClass = await prisma.classSchedule.update({\r\n+      where: { id },\r\n+      data: { status: 'cancelled' },\r\n+    });\r\n+    res.json(cancelledClass); // Return the updated class\r\n+\r\n+    // Option 2: Hard delete (uncomment if you truly want to remove from DB)\r\n+    /*\r\n+    // First, delete related bookings and attendance records\r\n+    await prisma.booking.deleteMany({ where: { scheduleId: id } });\r\n+    await prisma.attendance.deleteMany({ where: { scheduleId: id } });\r\n+\r\n+    // Then, delete the class schedule\r\n+    await prisma.classSchedule.delete({ where: { id } });\r\n+    res.status(204).send(); // No content for successful deletion\r\n+    */\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error deleting class by admin:', error);\r\n+    res.status(500).json({ error: 'Failed to delete class.' });\r\n+  }\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753032242832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -263,11 +263,20 @@\n       },\r\n       include: {\r\n         trainer: { select: { id: true, name: true } }, // Include trainer ID and name\r\n         bookings: {\r\n-          where: { status: 'confirmed' },\r\n-          select: { id: true }\r\n-        },\r\n+           where: { status: 'confirmed' },\r\n+          include: { // <--- This is the key change: use `include`\r\n+            member: { // <--- And specify what to include from the related `member`\r\n+              select: {\r\n+                id: true,\r\n+                firstName: true,\r\n+                lastName: true,\r\n+                name: true // Include 'name' as a fallback as you used 'b.member.name'\r\n+              }\r\n+            }\r\n+          }\r\n+        },\r\n         attendances: {\r\n           select: { id: true, status: true }\r\n         },\r\n         location: { select: { name: true } }\r\n"
                },
                {
                    "date": 1753033499538,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -263,20 +263,11 @@\n       },\r\n       include: {\r\n         trainer: { select: { id: true, name: true } }, // Include trainer ID and name\r\n         bookings: {\r\n-           where: { status: 'confirmed' },\r\n-          include: { // <--- This is the key change: use `include`\r\n-            member: { // <--- And specify what to include from the related `member`\r\n-              select: {\r\n-                id: true,\r\n-                firstName: true,\r\n-                lastName: true,\r\n-                name: true // Include 'name' as a fallback as you used 'b.member.name'\r\n-              }\r\n-            }\r\n-          }\r\n-        },\r\n+          where: { status: 'confirmed' },\r\n+          select: { id: true }\r\n+        },\r\n         attendances: {\r\n           select: { id: true, status: true }\r\n         },\r\n         location: { select: { name: true } }\r\n"
                },
                {
                    "date": 1753034066858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -263,11 +263,19 @@\n       },\r\n       include: {\r\n         trainer: { select: { id: true, name: true } }, // Include trainer ID and name\r\n         bookings: {\r\n-          where: { status: 'confirmed' },\r\n-          select: { id: true }\r\n-        },\r\n+  where: { status: 'confirmed' },\r\n+  include: {\r\n+    member: {\r\n+      select: {\r\n+        id: true,\r\n+        firstName: true,\r\n+        lastName: true\r\n+      }\r\n+    }\r\n+  }\r\n+},\r\n         attendances: {\r\n           select: { id: true, status: true }\r\n         },\r\n         location: { select: { name: true } }\r\n"
                }
            ],
            "date": 1752751780645,
            "name": "Commit-0",
            "content": "// gym-api/src/controllers/schedule.controller.ts\r\nimport { Request, Response } from 'express';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Extend Request to include user property from auth middleware\r\ninterface AuthenticatedRequest extends Request {\r\n  user?: {\r\n    id: string; // User.id\r\n    profileId?: string; // Trainer.id (if role is trainer)\r\n    role: string; // User.role\r\n    clubId?: string;\r\n    canCreateClasses?: boolean;\r\n  };\r\n}\r\n\r\n// GET /api/schedule/trainer/my - Fetch classes for the logged-in trainer\r\nexport const getTrainerSchedule = async (req: AuthenticatedRequest, res: Response) => {\r\n  const trainerId = req.user?.profileId; // Use profileId (Trainer.id)\r\n  const userRole = req.user?.role;\r\n\r\n  if (userRole !== 'trainer' || !trainerId) {\r\n    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n  }\r\n\r\n  const { startDate, endDate, classType, status } = req.query;\r\n\r\n  try {\r\n    const classes = await prisma.classSchedule.findMany({\r\n      where: {\r\n        trainerId: trainerId, // Filter by the authenticated trainer's ID\r\n        date: {\r\n          gte: startDate ? new Date(String(startDate)) : undefined,\r\n          lte: endDate ? new Date(String(endDate)) : undefined,\r\n        },\r\n        classType: classType ? String(classType) : undefined,\r\n        status: status ? String(status) : undefined,\r\n      },\r\n      include: {\r\n        trainer: { select: { name: true } }, // Include trainer name for display\r\n        bookings: {\r\n          where: { status: 'confirmed' }, // Count confirmed bookings\r\n          select: { id: true }\r\n        },\r\n        attendances: { // Include for class attendance summary\r\n          select: { id: true, status: true }\r\n        },\r\n        location: { select: { name: true } } // Include location name\r\n      },\r\n      orderBy: [{ date: 'asc' }],\r\n    });\r\n\r\n    const classesWithDetails = classes.map(cls => ({\r\n      ...cls,\r\n      // Format date for consistent display if needed, otherwise send as is\r\n      date: cls.date.toISOString(), // Ensure it's an ISO string for frontend parsing\r\n      trainerName: cls.trainer.name, // Use the name from the included trainer\r\n      location: cls.location?.name || 'N/A', // Use location name\r\n      currentAttendance: cls.bookings.length,\r\n      totalAttended: cls.attendances.filter(att => att.status === 'present').length,\r\n      totalAbsent: cls.attendances.filter(att => att.status === 'absent').length,\r\n    }));\r\n\r\n    res.json(classesWithDetails);\r\n  } catch (error) {\r\n    console.error('Error fetching trainer classes:', error);\r\n    res.status(500).json({ error: 'Error fetching trainer classes' });\r\n  }\r\n};\r\n\r\n// POST /api/schedule/trainer - Create a new class by trainer\r\nexport const createClass = async (req: AuthenticatedRequest, res: Response) => {\r\n  const trainerId = req.user?.profileId; // Trainer's actual ID\r\n  const clubId = req.user?.clubId; // Trainer's club ID\r\n  const canCreateClasses = req.user?.canCreateClasses; // Permission from JWT\r\n\r\n  if (req.user?.role !== 'trainer' || !trainerId || !clubId) {\r\n    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n  }\r\n  if (!canCreateClasses) {\r\n    return res.status(403).json({ error: 'Not authorized to create classes.' });\r\n  }\r\n\r\n  const { title, date, time, locationId, maxCapacity, duration, classType } = req.body;\r\n\r\n  if (!title || !date || !time || !locationId || !maxCapacity || !duration || !classType) {\r\n    return res.status(400).json({ error: 'Missing required fields to create class.' });\r\n  }\r\n\r\n  try {\r\n    const classDateTime = new Date(`${date}T${time}:00`); // Combine date and time\r\n\r\n    const newClass = await prisma.classSchedule.create({\r\n      data: {\r\n        title,\r\n        date: classDateTime,\r\n        locationId,\r\n        clubId,\r\n        trainerId, // Auto-assign to logged-in trainer\r\n        maxCapacity,\r\n        duration,\r\n        classType,\r\n        status: 'scheduled',\r\n      },\r\n      include: {\r\n        trainer: { select: { name: true } },\r\n        location: { select: { name: true } }\r\n      }\r\n    });\r\n\r\n    // Format for consistent frontend response\r\n    const formattedClass = {\r\n        ...newClass,\r\n        date: newClass.date.toISOString(),\r\n        trainerName: newClass.trainer.name,\r\n        location: newClass.location?.name || 'N/A',\r\n        currentAttendance: 0, // New class has 0 attendance\r\n        totalAttended: 0,\r\n        totalAbsent: 0,\r\n    };\r\n\r\n    res.status(201).json(formattedClass);\r\n  } catch (error) {\r\n    console.error('Error creating class:', error);\r\n    res.status(500).json({ error: 'Failed to create class.' });\r\n  }\r\n};\r\n\r\n// PATCH /api/schedule/trainer/:id - Update a class by trainer\r\nexport const updateClass = async (req: AuthenticatedRequest, res: Response) => {\r\n  const trainerId = req.user?.profileId;\r\n  const { id } = req.params; // Class Schedule ID\r\n  const { title, date, time, locationId, maxCapacity, duration, classType, status } = req.body;\r\n\r\n  if (req.user?.role !== 'trainer' || !trainerId) {\r\n    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n  }\r\n\r\n  try {\r\n    const existingClass = await prisma.classSchedule.findUnique({\r\n      where: { id },\r\n      select: { trainerId: true, date: true } // Select date to preserve time if only date is updated\r\n    });\r\n\r\n    if (!existingClass || existingClass.trainerId !== trainerId) {\r\n      return res.status(403).json({ error: 'Not authorized to update this class.' });\r\n    }\r\n\r\n    const updatedData: any = {\r\n      title,\r\n      locationId,\r\n      maxCapacity,\r\n      duration,\r\n      classType,\r\n      status // Allow updating status (e.g., to 'cancelled' or 'completed')\r\n    };\r\n\r\n    // Handle date and time updates\r\n    if (date && time) {\r\n      updatedData.date = new Date(`${date}T${time}:00`);\r\n    } else if (date) {\r\n      // If only date is provided, preserve existing time\r\n      const existingDateTime = existingClass.date;\r\n      const newDate = new Date(date);\r\n      newDate.setHours(existingDateTime.getHours(), existingDateTime.getMinutes(), existingDateTime.getSeconds(), existingDateTime.getMilliseconds());\r\n      updatedData.date = newDate;\r\n    } else if (time) {\r\n        // If only time is provided, update existing date's time\r\n        const existingDateTime = existingClass.date;\r\n        const [hours, minutes] = time.split(':').map(Number);\r\n        existingDateTime.setHours(hours, minutes, 0, 0);\r\n        updatedData.date = existingDateTime;\r\n    }\r\n\r\n\r\n    const updatedClass = await prisma.classSchedule.update({\r\n      where: { id },\r\n      data: updatedData,\r\n      include: {\r\n        trainer: { select: { name: true } },\r\n        bookings: { where: { status: 'confirmed' }, select: { id: true } },\r\n        attendances: { select: { id: true, status: true } },\r\n        location: { select: { name: true } }\r\n      }\r\n    });\r\n\r\n    const formattedClass = {\r\n        ...updatedClass,\r\n        date: updatedClass.date.toISOString(),\r\n        trainerName: updatedClass.trainer.name,\r\n        location: updatedClass.location?.name || 'N/A',\r\n        currentAttendance: updatedClass.bookings.length,\r\n        totalAttended: updatedClass.attendances.filter(att => att.status === 'present').length,\r\n        totalAbsent: updatedClass.attendances.filter(att => att.status === 'absent').length,\r\n    };\r\n\r\n    res.json(formattedClass);\r\n  } catch (error) {\r\n    console.error('Error updating class:', error);\r\n    res.status(500).json({ error: 'Failed to update class.' });\r\n  }\r\n};\r\n\r\n// DELETE /api/schedule/trainer/:id - Cancel a class by trainer (updates status to 'cancelled')\r\nexport const cancelClass = async (req: AuthenticatedRequest, res: Response) => {\r\n  const trainerId = req.user?.profileId;\r\n  const { id } = req.params; // Class Schedule ID\r\n\r\n  if (req.user?.role !== 'trainer' || !trainerId) {\r\n    return res.status(403).json({ error: 'Access denied. Trainer role required.' });\r\n  }\r\n\r\n  try {\r\n    const existingClass = await prisma.classSchedule.findUnique({\r\n      where: { id },\r\n      select: { trainerId: true }\r\n    });\r\n\r\n    if (!existingClass || existingClass.trainerId !== trainerId) {\r\n      return res.status(403).json({ error: 'Not authorized to cancel this class.' });\r\n    }\r\n\r\n    // Update status to 'cancelled' (recommended over hard delete for history)\r\n    const cancelledClass = await prisma.classSchedule.update({\r\n      where: { id },\r\n      data: { status: 'cancelled' },\r\n    });\r\n    res.json(cancelledClass); // Return the updated class\r\n  } catch (error) {\r\n    console.error('Error cancelling class:', error);\r\n    res.status(500).json({ error: 'Failed to cancel class.' });\r\n  }\r\n};"
        }
    ]
}