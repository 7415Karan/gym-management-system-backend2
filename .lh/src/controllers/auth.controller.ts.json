{
    "sourceFile": "src/controllers/auth.controller.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1752123806367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752733335811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n import { Request, Response } from 'express';\r\n import jwt from 'jsonwebtoken';\r\n import bcrypt from 'bcryptjs';\r\n import prisma from '../lib/prisma';\r\n+import { verifyPasswordSetupToken, hashPassword } from '../utils/authUtils';\r\n \r\n export const loginController = async (req: Request, res: Response) => {\r\n   const { email, password } = req.body;\r\n \r\n@@ -39,4 +40,50 @@\n     console.error(err);\r\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n };\r\n+\r\n+export const setupPassword = async (req: Request, res: Response) => {\r\n+  const { token, newPassword } = req.body;\r\n+\r\n+  if (!token || !newPassword) {\r\n+    return res.status(400).json({ error: 'Token and new password are required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    // 1. Verify the token\r\n+    const decodedToken = verifyPasswordSetupToken(token);\r\n+\r\n+    if (!decodedToken) {\r\n+      return res.status(401).json({ error: 'Invalid or expired password setup token.' });\r\n+    }\r\n+\r\n+    // 2. Find the user\r\n+    const user = await prisma.user.findUnique({\r\n+      where: { id: decodedToken.userId },\r\n+    });\r\n+\r\n+    if (!user) {\r\n+      return res.status(404).json({ error: 'User not found.' });\r\n+    }\r\n+\r\n+    // Ensure the email in the token matches the user's email\r\n+    if (user.email !== decodedToken.email) {\r\n+        return res.status(403).json({ error: 'Token mismatch.' });\r\n+    }\r\n+\r\n+    // 3. Hash the new password\r\n+    const hashedPassword = await hashPassword(newPassword);\r\n+\r\n+    // 4. Update the user's password\r\n+    await prisma.user.update({\r\n+      where: { id: user.id },\r\n+      data: { password: hashedPassword },\r\n+    });\r\n+\r\n+    res.status(200).json({ message: 'Password set successfully. You can now log in.' });\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error setting up password:', error);\r\n+    res.status(500).json({ error: 'Failed to set password.' });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1752750136177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,32 +9,45 @@\n \r\n   try {\r\n     const user = await prisma.user.findUnique({\r\n       where: { email },\r\n+       include: {\r\n+        trainerProfile: true,\r\n+        memberProfile: true,\r\n+  }\r\n     });\r\n \r\n     if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n     const valid = await bcrypt.compare(password, user.password);\r\n     if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n+    const tokenPayload: Record<string, any> = {\r\n+      id: user.id,\r\n+      email: user.email, // Include email in token for convenience\r\n+      role: user.role,\r\n+      clubId: user.clubId,\r\n+    };\r\n+\r\n+    // Conditionally add profile-specific IDs and permissions\r\n+    if (user.role === 'trainer' && user.trainerProfile) {\r\n+      tokenPayload.profileType = 'trainer'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileId = user.trainerProfile.id;\r\n+      tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n+    } else if (user.role === 'member' && user.memberProfile) {\r\n+      tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileId = user.memberProfile.id;\r\n+    }\r\n+\r\n+\r\n     const token = jwt.sign(\r\n-      {\r\n-        id: user.id,\r\n-        role: user.role,\r\n-        clubId: user.clubId,\r\n-      },\r\n+      tokenPayload,\r\n       process.env.JWT_SECRET!,\r\n       { expiresIn: '7d' }\r\n     );\r\n \r\n     res.json({\r\n-      user: {\r\n-        id: user.id,\r\n-        email: user.email,\r\n-        role: user.role,\r\n-        clubId: user.clubId,\r\n-      },\r\n+      user: tokenPayload, // Send the same enriched payload back to the frontend\r\n       token,\r\n     });\r\n   } catch (err) {\r\n     console.error(err);\r\n"
                },
                {
                    "date": 1752751729418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,10 @@\n     if (user.role === 'trainer' && user.trainerProfile) {\r\n       tokenPayload.profileType = 'trainer'; // Indicate which profile type this ID belongs to\r\n       tokenPayload.profileId = user.trainerProfile.id;\r\n       tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n-    } else if (user.role === 'member' && user.memberProfile) {\r\n+    } \r\n+    else if (user.role === 'member' && user.memberProfile) {\r\n       tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n       tokenPayload.profileId = user.memberProfile.id;\r\n     }\r\n \r\n"
                },
                {
                    "date": 1752752262002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,103 @@\n+import { Request, Response } from 'express';\r\n+import jwt from 'jsonwebtoken';\r\n+import bcrypt from 'bcryptjs';\r\n+import prisma from '../lib/prisma';\r\n+import { verifyPasswordSetupToken, hashPassword } from '../utils/authUtils';\r\n+\r\n+export const loginController = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n+\r\n+  try {\r\n+    const user = await prisma.user.findUnique({\r\n+      where: { email },\r\n+       include: {\r\n+        trainerProfile: true,\r\n+        memberProfile: true,\r\n+  }\r\n+    });\r\n+\r\n+    if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n+\r\n+    const valid = await bcrypt.compare(password, user.password);\r\n+    if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n+\r\n+    const tokenPayload: Record<string, any> = {\r\n+      id: user.id,\r\n+      email: user.email, // Include email in token for convenience\r\n+      role: user.role,\r\n+      clubId: user.clubId,\r\n+    };\r\n+\r\n+    // Conditionally add profile-specific IDs and permissions\r\n+    if (user.role === 'trainer' && user.trainerProfile) {\r\n+      tokenPayload.profileType = 'trainer'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileId = user.trainerProfile.id;\r\n+      tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n+    } \r\n+    else if (user.role === 'member' && user.memberProfile) {\r\n+      tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileId = user.memberProfile.id;\r\n+    }\r\n+\r\n+\r\n+    const token = jwt.sign(\r\n+      tokenPayload,\r\n+      process.env.JWT_SECRET!,\r\n+      { expiresIn: '7d' }\r\n+    );\r\n+\r\n+    res.json({\r\n+      user: tokenPayload, // Send the same enriched payload back to the frontend\r\n+      token,\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+};\r\n+\r\n+export const setupPassword = async (req: Request, res: Response) => {\r\n+  const { token, newPassword } = req.body;\r\n+\r\n+  if (!token || !newPassword) {\r\n+    return res.status(400).json({ error: 'Token and new password are required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    // 1. Verify the token\r\n+    const decodedToken = verifyPasswordSetupToken(token);\r\n+\r\n+    if (!decodedToken) {\r\n+      return res.status(401).json({ error: 'Invalid or expired password setup token.' });\r\n+    }\r\n+\r\n+    // 2. Find the user\r\n+    const user = await prisma.user.findUnique({\r\n+      where: { id: decodedToken.userId },\r\n+    });\r\n+\r\n+    if (!user) {\r\n+      return res.status(404).json({ error: 'User not found.' });\r\n+    }\r\n+\r\n+    // Ensure the email in the token matches the user's email\r\n+    if (user.email !== decodedToken.email) {\r\n+        return res.status(403).json({ error: 'Token mismatch.' });\r\n+    }\r\n+\r\n+    // 3. Hash the new password\r\n+    const hashedPassword = await hashPassword(newPassword);\r\n+\r\n+    // 4. Update the user's password\r\n+    await prisma.user.update({\r\n+      where: { id: user.id },\r\n+      data: { password: hashedPassword },\r\n+    });\r\n+\r\n+    res.status(200).json({ message: 'Password set successfully. You can now log in.' });\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error setting up password:', error);\r\n+    res.status(500).json({ error: 'Failed to set password.' });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1752809643086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,15 @@\n     });\r\n \r\n     if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n+    console.log('Login Controller Debug: User found:', user.email, 'with role:', user.role);\r\n+    console.log('Login Controller Debug: Has trainerProfile:', !!user.trainerProfile);\r\n+    if (user.trainerProfile) {\r\n+        console.log('Login Controller Debug: trainerProfile ID:', user.trainerProfile.id);\r\n+    }\r\n+    // --- END \r\n+\r\n     const valid = await bcrypt.compare(password, user.password);\r\n     if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n     const tokenPayload: Record<string, any> = {\r\n@@ -38,8 +45,9 @@\n       tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n       tokenPayload.profileId = user.memberProfile.id;\r\n     }\r\n \r\n+    console.log('Login Controller Debug: Final tokenPayload before signing:', tokenPayload);\r\n \r\n     const token = jwt.sign(\r\n       tokenPayload,\r\n       process.env.JWT_SECRET!,\r\n@@ -51,8 +59,9 @@\n       token,\r\n     });\r\n   } catch (err) {\r\n     console.error(err);\r\n+    console.error('Login Controller Error:', err); \r\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n };\r\n \r\n"
                }
            ],
            "date": 1752123806367,
            "name": "Commit-0",
            "content": "import { Request, Response } from 'express';\r\nimport jwt from 'jsonwebtoken';\r\nimport bcrypt from 'bcryptjs';\r\nimport prisma from '../lib/prisma';\r\n\r\nexport const loginController = async (req: Request, res: Response) => {\r\n  const { email, password } = req.body;\r\n\r\n  try {\r\n    const user = await prisma.user.findUnique({\r\n      where: { email },\r\n    });\r\n\r\n    if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n\r\n    const valid = await bcrypt.compare(password, user.password);\r\n    if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n\r\n    const token = jwt.sign(\r\n      {\r\n        id: user.id,\r\n        role: user.role,\r\n        clubId: user.clubId,\r\n      },\r\n      process.env.JWT_SECRET!,\r\n      { expiresIn: '7d' }\r\n    );\r\n\r\n    res.json({\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        role: user.role,\r\n        clubId: user.clubId,\r\n      },\r\n      token,\r\n    });\r\n  } catch (err) {\r\n    console.error(err);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n};\r\n"
        }
    ]
}