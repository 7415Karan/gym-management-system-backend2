{
    "sourceFile": "src/controllers/trainerSchedule.controller.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752751215271,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752751215271,
            "name": "Commit-0",
            "content": "// src/controllers/trainerSchedule.controller.ts\r\nimport { Request, Response } from 'express';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Extend Request to include user property from auth middleware\r\ninterface AuthenticatedRequest extends Request {\r\n  user?: {\r\n    id: string; // trainerId\r\n    clubId: string;\r\n    // ... other user properties\r\n    canCreateClasses?: boolean; // From Trainer model\r\n  };\r\n}\r\n\r\nexport const getTrainerSchedule = async (req: AuthenticatedRequest, res: Response) => {\r\n  const trainerId = req.user?.id;\r\n  if (!trainerId) {\r\n    return res.status(401).json({ error: 'Trainer not authenticated.' });\r\n  }\r\n\r\n  const { startDate, endDate, classType, status } = req.query;\r\n\r\n  try {\r\n    const classes = await prisma.classSchedule.findMany({\r\n      where: {\r\n        trainerId: trainerId,\r\n        date: {\r\n          gte: startDate ? new Date(String(startDate)) : undefined,\r\n          lte: endDate ? new Date(String(endDate)) : undefined,\r\n        },\r\n        classType: classType ? String(classType) : undefined,\r\n        status: status ? String(status) : undefined, // 'scheduled', 'cancelled', 'completed'\r\n      },\r\n      include: {\r\n        trainer: { select: { firstName: true, lastName: true } }, // To auto-fill trainer name\r\n        bookings: {\r\n          where: { status: 'confirmed' }, // Count confirmed bookings as current attendance\r\n          select: { id: true }\r\n        },\r\n        attendances: { // Include for class attendance summary\r\n          select: { id: true, status: true }\r\n        }\r\n      },\r\n      orderBy: [{ date: 'asc' }],\r\n    });\r\n\r\n    // Augment classes with current attendance count and marked attendance summary\r\n    const classesWithDetails = classes.map(cls => ({\r\n      ...cls,\r\n      trainerName: `${cls.trainer.firstName} ${cls.trainer.lastName}`,\r\n      currentAttendance: cls.bookings.length, // Confirmed bookings count\r\n      totalAttended: cls.attendances.filter(att => att.status === 'present').length, // Actual marked attendance\r\n      totalAbsent: cls.attendances.filter(att => att.status === 'absent').length,\r\n    }));\r\n\r\n    res.json(classesWithDetails);\r\n  } catch (error) {\r\n    console.error('Error fetching trainer classes:', error);\r\n    res.status(500).json({ error: 'Error fetching trainer classes' });\r\n  }\r\n};\r\n\r\nexport const createClass = async (req: AuthenticatedRequest, res: Response) => {\r\n    const trainerId = req.user?.id;\r\n    const clubId = req.user?.clubId; // Assuming clubId is part of user object\r\n    const canCreateClasses = req.user?.canCreateClasses; // Check permission\r\n\r\n    if (!trainerId || !clubId) {\r\n        return res.status(401).json({ error: 'Authentication required.' });\r\n    }\r\n    if (!canCreateClasses) {\r\n        return res.status(403).json({ error: 'Not authorized to create classes.' });\r\n    }\r\n\r\n    const { title, date, time, location, maxCapacity, duration, classType } = req.body;\r\n\r\n    if (!title || !date || !time || !maxCapacity || !duration || !classType) {\r\n        return res.status(400).json({ error: 'Missing required fields to create class.' });\r\n    }\r\n\r\n    try {\r\n        // Combine date and time if you're storing it as a single DateTime object\r\n        const classDateTime = new Date(`${date}T${time}:00`);\r\n\r\n        const newClass = await prisma.classSchedule.create({\r\n            data: {\r\n                title,\r\n                date: classDateTime,\r\n                // If you store time separately: time,\r\n                location,\r\n                clubId,\r\n                trainerId,\r\n                maxCapacity,\r\n                duration,\r\n                classType,\r\n                status: 'scheduled',\r\n            },\r\n        });\r\n        res.status(201).json(newClass);\r\n    } catch (error) {\r\n        console.error('Error creating class:', error);\r\n        res.status(500).json({ error: 'Failed to create class.' });\r\n    }\r\n};\r\n\r\nexport const updateClass = async (req: AuthenticatedRequest, res: Response) => {\r\n    const trainerId = req.user?.id;\r\n    const { id } = req.params; // Class Schedule ID\r\n    const { title, date, time, location, maxCapacity, duration, classType, status } = req.body;\r\n\r\n    if (!trainerId) {\r\n        return res.status(401).json({ error: 'Authentication required.' });\r\n    }\r\n\r\n    try {\r\n        const existingClass = await prisma.classSchedule.findUnique({\r\n            where: { id },\r\n            select: { trainerId: true }\r\n        });\r\n\r\n        if (!existingClass || existingClass.trainerId !== trainerId) {\r\n            return res.status(403).json({ error: 'Not authorized to update this class.' });\r\n        }\r\n\r\n        const updatedData: any = {\r\n            title,\r\n            location,\r\n            maxCapacity,\r\n            duration,\r\n            classType,\r\n            status // Allow updating status (e.g., to 'cancelled' or 'completed')\r\n        };\r\n\r\n        if (date && time) {\r\n            updatedData.date = new Date(`${date}T${time}:00`);\r\n        } else if (date) {\r\n            // If only date is provided, preserve existing time or set to start of day\r\n            const existingDate = existingClass.date; // Assuming existingClass.date is available in existingClass\r\n            const newDate = new Date(date);\r\n            newDate.setHours(existingDate.getHours(), existingDate.getMinutes(), existingDate.getSeconds());\r\n            updatedData.date = newDate;\r\n        }\r\n        // If only time is provided, similarly, update existing date's time\r\n\r\n        const updatedClass = await prisma.classSchedule.update({\r\n            where: { id },\r\n            data: updatedData,\r\n        });\r\n\r\n        res.json(updatedClass);\r\n    } catch (error) {\r\n        console.error('Error updating class:', error);\r\n        res.status(500).json({ error: 'Failed to update class.' });\r\n    }\r\n};\r\n\r\nexport const cancelClass = async (req: AuthenticatedRequest, res: Response) => {\r\n    const trainerId = req.user?.id;\r\n    const { id } = req.params; // Class Schedule ID\r\n\r\n    if (!trainerId) {\r\n        return res.status(401).json({ error: 'Authentication required.' });\r\n    }\r\n\r\n    try {\r\n        const existingClass = await prisma.classSchedule.findUnique({\r\n            where: { id },\r\n            select: { trainerId: true }\r\n        });\r\n\r\n        if (!existingClass || existingClass.trainerId !== trainerId) {\r\n            return res.status(403).json({ error: 'Not authorized to cancel this class.' });\r\n        }\r\n\r\n        // Option 1: Mark as cancelled (recommended for history)\r\n        const cancelledClass = await prisma.classSchedule.update({\r\n            where: { id },\r\n            data: { status: 'cancelled' },\r\n        });\r\n        res.json(cancelledClass);\r\n\r\n        // Option 2: Truly delete (less recommended if you need history)\r\n        /*\r\n        await prisma.booking.deleteMany({ where: { scheduleId: id } });\r\n        await prisma.attendance.deleteMany({ where: { scheduleId: id } });\r\n        await prisma.classSchedule.delete({ where: { id } });\r\n        res.status(204).send();\r\n        */\r\n    } catch (error) {\r\n        console.error('Error cancelling class:', error);\r\n        res.status(500).json({ error: 'Failed to cancel class.' });\r\n    }\r\n};"
        }
    ]
}